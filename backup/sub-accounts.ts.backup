import { CakemailAPI } from '../cakemail-api.js';
import { handleCakemailError } from '../utils/errors.js';

// Define types locally to handle the sub-account data structure
interface SubAccount {
  id: string;
  name?: string;
  status?: string;
  lineage?: string;
  partner?: boolean;
  account_owner?: {
    email?: string;
    name?: string;
  };
  created_on?: string;
  expires_on?: string;
  usage_limits?: any;
}

// List sub-accounts with filtering and pagination
export async function handleListSubAccounts(args: any, api: CakemailAPI) {
  try {
    const {
      page,
      per_page,
      status,
      name,
      recursive,
      partner_account_id,
      with_count
    } = args;

    const params: any = {};
    
    // Build pagination parameters
    if (page !== undefined || per_page !== undefined || with_count !== undefined) {
      params.pagination = {
        page: page || 1,
        per_page: per_page || 50,
        with_count: with_count !== false
      };
    }
    
    // Build filters
    if (status || name) {
      params.filters = {};
      if (status) params.filters.status = status;
      if (name) params.filters.name = name;
    }
    
    // Add other parameters
    if (partner_account_id !== undefined) params.partner_account_id = partner_account_id;
    if (recursive !== undefined) params.recursive = recursive;
    
    // Default sort by creation date (newest first)
    params.sort = {
      sort: 'created_on',
      order: 'desc'
    };

    const result = await api.subAccounts.listSubAccounts(params);
    
    const total = result.pagination?.count || 0;
    const subAccountsList = result.data?.slice(0, 20).map((account: SubAccount) => ({
      id: account.id,
      name: account.name || 'N/A',
      status: account.status || 'N/A',
      lineage: account.lineage || 'N/A',
      partner: account.partner || false,
      owner_email: account.account_owner?.email || 'N/A',
      owner_name: account.account_owner?.name || 'N/A',
      created_on: account.created_on || 'N/A',
      expires_on: account.expires_on || 'N/A'
    }));

    return {
      content: [{
        type: 'text',
        text: `üìä **Sub-Accounts Export Generated Successfully**\n\n` +
              `**Export Details:**\n` +
              `‚Ä¢ Format: ${format.toUpperCase()}\n` +
              `‚Ä¢ Filename: ${exportFilename}.${format}\n` +
              `‚Ä¢ Total Accounts: ${enhancedAccounts.length}\n` +
              `‚Ä¢ File Size: ${fileSizeKB} KB\n` +
              `‚Ä¢ Generated: ${new Date().toLocaleString()}\n\n` +
              `**Export Options:**\n` +
              `‚Ä¢ Include Usage Stats: ${include_usage_stats ? 'Yes' : 'No'}\n` +
              `‚Ä¢ Include Contact Counts: ${include_contact_counts ? 'Yes' : 'No'}\n` +
              `‚Ä¢ Include Owner Details: ${include_owner_details ? 'Yes' : 'No'}\n` +
              `‚Ä¢ Status Filter: ${status_filter || 'None'}\n` +
              `‚Ä¢ Recursive: ${recursive ? 'Yes' : 'No'}\n` +
              `‚Ä¢ Partner Account ID: ${partner_account_id || 'None'}\n\n` +
              `**Sample Data (First Account):**\n` +
              `‚Ä¢ ID: ${enhancedAccounts[0].id}\n` +
              `‚Ä¢ Name: ${enhancedAccounts[0].name}\n` +
              `‚Ä¢ Status: ${enhancedAccounts[0].status}\n` +
              `‚Ä¢ Owner: ${enhancedAccounts[0].owner_name || 'N/A'} (${enhancedAccounts[0].owner_email || 'N/A'})\n\n` +
              `**üìÅ Export Content Preview (First 500 characters):**\n` +
              `\`\`\`${format}\n${exportContent.substring(0, 500)}${exportContent.length > 500 ? '...' : ''}\n\`\`\`\n\n` +
              `**üíæ To save the complete export file:**\n` +
              `1. Copy the content above\n` +
              `2. Save as \`${exportFilename}.${format}\`\n` +
              `3. Use appropriate software to open (Excel for CSV, text editor for JSON)\n\n` +
              `**üîó Full Export Content:**\n` +
              `\`\`\`${format}\n${exportContent}\n\`\`\``
      }]
    };
  } catch (error) {
    return handleCakemailError(error);
  }
} [
        {
          type: 'text',
          text: `üè¢ **Sub-Accounts (${total} total)**\n\n` +
                `**Applied Filters:**\n` +
                `‚Ä¢ Status: ${status || 'all'}\n` +
                `‚Ä¢ Name Filter: ${name || 'none'}\n` +
                `‚Ä¢ Recursive: ${recursive || false}\n` +
                `‚Ä¢ Partner Account ID: ${partner_account_id || 'none'}\n\n` +
                `**Showing ${subAccountsList?.length || 0} sub-accounts:**\n\n` +
                (subAccountsList?.map((acc: any, i: number) => 
                  `${i + 1}. **${acc.name}** (${acc.id})\n` +
                  `   üè∑Ô∏è Status: ${acc.status}\n` +
                  `   üìß Owner: ${acc.owner_name} (${acc.owner_email})\n` +
                  `   üîó Lineage: ${acc.lineage}\n` +
                  `   ü§ù Partner: ${acc.partner ? 'Yes' : 'No'}\n` +
                  `   üìÖ Created: ${acc.created_on}\n` +
                  `   ‚è∞ Expires: ${acc.expires_on}`
                ).join('\n\n') || 'No sub-accounts found.') +
                (total > 20 ? `\n\n**... and ${total - 20} more sub-accounts**` : '') +
                `\n\n**Full Response:**\n${JSON.stringify(result, null, 2)}`,
        },
      ],
    };
  } catch (error) {
    return handleCakemailError(error);
  }
}

// Create a new sub-account
export async function handleCreateSubAccount(args: any, api: CakemailAPI) {
  try {
    const {
      name,
      email,
      password,
      company,
      language,
      timezone,
      country,
      phone,
      website,
      description,
      partner_account_id,
      skip_verification
    } = args;

    // Validate required fields
    if (!name || !email || !password) {
      return {
        content: [{
          type: 'text',
          text: '‚ùå **Missing Required Fields**\n\nRequired: name, email, password'
        }]
      };
    }

    // Build sub-account data
    const subAccountData: any = {
      name,
      email,
      password
    };
    
    // Add optional fields if provided
    if (company) subAccountData.company = company;
    if (language) subAccountData.language = language;
    if (timezone) subAccountData.timezone = timezone;
    if (country) subAccountData.country = country;
    if (phone) subAccountData.phone = phone;
    if (website) subAccountData.website = website;
    if (description) subAccountData.description = description;

    // Build options
    const options: any = {};
    if (partner_account_id !== undefined) options.partner_account_id = partner_account_id;
    if (skip_verification !== undefined) options.skip_verification = skip_verification;

    const result = await api.subAccounts.createSubAccount(subAccountData, options);

    return {
      content: [{
        type: 'text',
        text: `‚úÖ **Sub-Account Created Successfully**\n\n` +
              `üè¢ **Account Details:**\n` +
              `‚Ä¢ ID: ${result.data?.id}\n` +
              `‚Ä¢ Name: ${name}\n` +
              `‚Ä¢ Email: ${email}\n` +
              `‚Ä¢ Company: ${company || 'N/A'}\n` +
              `‚Ä¢ Language: ${language || 'N/A'}\n` +
              `‚Ä¢ Country: ${country || 'N/A'}\n` +
              `‚Ä¢ Skip Verification: ${skip_verification || false}\n\n` +
              `**Full Response:**\n${JSON.stringify(result, null, 2)}`
      }]
    };
  } catch (error) {
    return handleCakemailError(error);
  }
}

// Get specific sub-account details
export async function handleGetSubAccount(args: any, api: CakemailAPI) {
  try {
    const { account_id } = args;

    if (!account_id) {
      return {
        content: [{
          type: 'text',
          text: '‚ùå **Missing Required Field**\n\nRequired: account_id'
        }]
      };
    }

    const result = await api.subAccounts.getSubAccount(account_id);
    const account = result.data;

    return {
      content: [{
        type: 'text',
        text: `üè¢ **Sub-Account Details**\n\n` +
              `**Account Information:**\n` +
              `‚Ä¢ ID: ${account?.id}\n` +
              `‚Ä¢ Name: ${account?.name || 'N/A'}\n` +
              `‚Ä¢ Status: ${account?.status || 'N/A'}\n` +
              `‚Ä¢ Lineage: ${account?.lineage || 'N/A'}\n` +
              `‚Ä¢ Partner: ${account?.partner ? 'Yes' : 'No'}\n\n` +
              `**Owner Information:**\n` +
              `‚Ä¢ Name: ${account?.account_owner?.name || 'N/A'}\n` +
              `‚Ä¢ Email: ${account?.account_owner?.email || 'N/A'}\n\n` +
              `**Dates:**\n` +
              `‚Ä¢ Created: ${account?.created_on || 'N/A'}\n` +
              `‚Ä¢ Expires: ${account?.expires_on || 'N/A'}\n\n` +
              `**Full Response:**\n${JSON.stringify(result, null, 2)}`
      }]
    };
  } catch (error) {
    return handleCakemailError(error);
  }
}

// Update sub-account information
export async function handleUpdateSubAccount(args: any, api: CakemailAPI) {
  try {
    const {
      account_id,
      name,
      email,
      company,
      language,
      timezone,
      country,
      phone,
      website,
      description
    } = args;

    if (!account_id) {
      return {
        content: [{
          type: 'text',
          text: '‚ùå **Missing Required Field**\n\nRequired: account_id'
        }]
      };
    }

    // Build update data with only provided fields
    const updateData: any = {};
    if (name !== undefined) updateData.name = name;
    if (email !== undefined) updateData.email = email;
    if (company !== undefined) updateData.company = company;
    if (language !== undefined) updateData.language = language;
    if (timezone !== undefined) updateData.timezone = timezone;
    if (country !== undefined) updateData.country = country;
    if (phone !== undefined) updateData.phone = phone;
    if (website !== undefined) updateData.website = website;
    if (description !== undefined) updateData.description = description;

    if (Object.keys(updateData).length === 0) {
      return {
        content: [{
          type: 'text',
          text: '‚ùå **No Update Data**\n\nAt least one field must be provided for update.'
        }]
      };
    }

    const result = await api.subAccounts.updateSubAccount(account_id, updateData);

    return {
      content: [{
        type: 'text',
        text: `‚úÖ **Sub-Account Updated Successfully**\n\n` +
              `üè¢ **Account Details:**\n` +
              `‚Ä¢ ID: ${account_id}\n` +
              `‚Ä¢ Fields Updated: ${Object.keys(updateData).join(', ')}\n\n` +
              `**Updated Values:**\n` +
              Object.entries(updateData).map(([key, value]) => `‚Ä¢ ${key}: ${value}`).join('\n') +
              `\n\n**Full Response:**\n${JSON.stringify(result, null, 2)}`
      }]
    };
  } catch (error) {
    return handleCakemailError(error);
  }
}

// Delete a sub-account
export async function handleDeleteSubAccount(args: any, api: CakemailAPI) {
  try {
    const { account_id } = args;

    if (!account_id) {
      return {
        content: [{
          type: 'text',
          text: '‚ùå **Missing Required Field**\n\nRequired: account_id'
        }]
      };
    }

    const result = await api.subAccounts.deleteSubAccount(account_id);

    return {
      content: [{
        type: 'text',
        text: `‚úÖ **Sub-Account Deleted Successfully**\n\n` +
              `üè¢ **Deleted Account:**\n` +
              `‚Ä¢ ID: ${account_id}\n` +
              `‚Ä¢ Status: ${result.data?.deleted ? 'Deleted' : 'Error'}\n\n` +
              `**‚ö†Ô∏è Warning:** This action is permanent and cannot be undone.\n\n` +
              `**Full Response:**\n${JSON.stringify(result, null, 2)}`
      }]
    };
  } catch (error) {
    return handleCakemailError(error);
  }
}

// Additional sub-account management handlers

// Suspend a sub-account
export async function handleSuspendSubAccount(args: any, api: CakemailAPI) {
  try {
    const { account_id } = args;

    if (!account_id) {
      return {
        content: [{
          type: 'text',
          text: '‚ùå **Missing Required Field**\n\nRequired: account_id'
        }]
      };
    }

    const result = await api.subAccounts.suspendSubAccount(account_id);

    return {
      content: [{
        type: 'text',
        text: `‚è∏Ô∏è **Sub-Account Suspended Successfully**\n\n` +
              `üè¢ **Account Details:**\n` +
              `‚Ä¢ ID: ${account_id}\n` +
              `‚Ä¢ Suspended: ${result.suspended ? 'Yes' : 'No'}\n\n` +
              `**Note:** The sub-account has been suspended and cannot access the platform until unsuspended.\n\n` +
              `**Full Response:**\n${JSON.stringify(result, null, 2)}`
      }]
    };
  } catch (error) {
    return handleCakemailError(error);
  }
}

// Unsuspend a sub-account
export async function handleUnsuspendSubAccount(args: any, api: CakemailAPI) {
  try {
    const { account_id } = args;

    if (!account_id) {
      return {
        content: [{
          type: 'text',
          text: '‚ùå **Missing Required Field**\n\nRequired: account_id'
        }]
      };
    }

    const result = await api.subAccounts.unsuspendSubAccount(account_id);

    return {
      content: [{
        type: 'text',
        text: `‚ñ∂Ô∏è **Sub-Account Unsuspended Successfully**\n\n` +
              `üè¢ **Account Details:**\n` +
              `‚Ä¢ ID: ${account_id}\n` +
              `‚Ä¢ Unsuspended: ${result.unsuspended ? 'Yes' : 'No'}\n\n` +
              `**Note:** The sub-account has been reactivated and can now access the platform.\n\n` +
              `**Full Response:**\n${JSON.stringify(result, null, 2)}`
      }]
    };
  } catch (error) {
    return handleCakemailError(error);
  }
}

// Confirm sub-account creation
export async function handleConfirmSubAccount(args: any, api: CakemailAPI) {
  try {
    const { account_id, confirmation_code, password } = args;

    if (!account_id || !confirmation_code) {
      return {
        content: [{
          type: 'text',
          text: '‚ùå **Missing Required Fields**\n\nRequired: account_id, confirmation_code'
        }]
      };
    }

    const confirmData: any = { confirmation_code };
    if (password) confirmData.password = password;

    const result = await api.subAccounts.confirmSubAccount(account_id, confirmData);

    return {
      content: [{
        type: 'text',
        text: `‚úÖ **Sub-Account Confirmed Successfully**\n\n` +
              `üè¢ **Account Details:**\n` +
              `‚Ä¢ ID: ${account_id}\n` +
              `‚Ä¢ Confirmed: ${result.data?.confirmed ? 'Yes' : 'No'}\n` +
              `‚Ä¢ Password Updated: ${password ? 'Yes' : 'No'}\n\n` +
              `**Note:** The sub-account is now confirmed and can be used.\n\n` +
              `**Full Response:**\n${JSON.stringify(result, null, 2)}`
      }]
    };
  } catch (error) {
    return handleCakemailError(error);
  }
}

// Resend verification email
export async function handleResendVerificationEmail(args: any, api: CakemailAPI) {
  try {
    const { email } = args;

    if (!email) {
      return {
        content: [{
          type: 'text',
          text: '‚ùå **Missing Required Field**\n\nRequired: email'
        }]
      };
    }

    const result = await api.subAccounts.resendVerificationEmail({ email });

    return {
      content: [{
        type: 'text',
        text: `üìß **Verification Email Resent Successfully**\n\n` +
              `**Email Details:**\n` +
              `‚Ä¢ Recipient: ${email}\n` +
              `‚Ä¢ Resent: ${result.verification_resent ? 'Yes' : 'No'}\n\n` +
              `**Note:** Please check the inbox (and spam folder) for the verification email.\n\n` +
              `**Full Response:**\n${JSON.stringify(result, null, 2)}`
      }]
    };
  } catch (error) {
    return handleCakemailError(error);
  }
}

// Convert sub-account to organization
export async function handleConvertSubAccountToOrganization(args: any, api: CakemailAPI) {
  try {
    const { account_id, migrate_owner } = args;

    if (!account_id) {
      return {
        content: [{
          type: 'text',
          text: '‚ùå **Missing Required Field**\n\nRequired: account_id'
        }]
      };
    }

    const convertData = { migrate_owner: migrate_owner !== false }; // Default to true

    const result = await api.subAccounts.convertSubAccountToOrganization(account_id, convertData);

    return {
      content: [{
        type: 'text',
        text: `üè¢ **Sub-Account Converted to Organization Successfully**\n\n` +
              `**Account Details:**\n` +
              `‚Ä¢ ID: ${account_id}\n` +
              `‚Ä¢ Migrate Owner: ${migrate_owner !== false ? 'Yes' : 'No'}\n` +
              `‚Ä¢ Status: ${result.data?.status || 'N/A'}\n\n` +
              `**Note:** The sub-account has been converted to an organization type.\n\n` +
              `**Full Response:**\n${JSON.stringify(result, null, 2)}`
      }]
    };
  } catch (error) {
    return handleCakemailError(error);
  }
}

// Get the latest sub-account
export async function handleGetLatestSubAccount(_args: any, api: CakemailAPI) {
  try {
    const result = await api.subAccounts.getLatestSubAccount();
    
    if (!result || !result.data) {
      return {
        content: [{
          type: 'text',
          text: 'üì≠ **No Sub-Accounts Found**\n\nThere are no sub-accounts in the system.'
        }]
      };
    }

    const account = result.data;

    return {
      content: [{
        type: 'text',
        text: `üè¢ **Latest Sub-Account**\n\n` +
              `**Account Information:**\n` +
              `‚Ä¢ ID: ${account.id}\n` +
              `‚Ä¢ Name: ${account.name || 'N/A'}\n` +
              `‚Ä¢ Status: ${account.status || 'N/A'}\n` +
              `‚Ä¢ Owner: ${account.account_owner?.name || 'N/A'} (${account.account_owner?.email || 'N/A'})\n` +
              `‚Ä¢ Created: ${account.created_on || 'N/A'}\n\n` +
              `**Full Response:**\n${JSON.stringify(result, null, 2)}`
      }]
    };
  } catch (error) {
    return handleCakemailError(error);
  }
}

// Search sub-accounts by name
export async function handleSearchSubAccountsByName(args: any, api: CakemailAPI) {
  try {
    const { name, page, per_page } = args;

    if (!name) {
      return {
        content: [{
          type: 'text',
          text: '‚ùå **Missing Required Field**\n\nRequired: name'
        }]
      };
    }

    const result = await api.subAccounts.searchSubAccountsByName(name, {
      page: page || 1,
      per_page: per_page || 50
    });

    const total = result.pagination?.count || 0;
    const accounts = result.data?.map((account: SubAccount) => ({
      id: account.id,
      name: account.name || 'N/A',
      status: account.status || 'N/A',
      owner_email: account.account_owner?.email || 'N/A'
    }));

    return {
      content: [{
        type: 'text',
        text: `üîç **Sub-Account Search Results**\n\n` +
              `**Search Query:** "${name}"\n` +
              `**Found:** ${total} matching sub-accounts\n\n` +
              `**Results:**\n` +
              (accounts?.map((acc: any, i: number) => 
                `${i + 1}. **${acc.name}** (${acc.id})\n` +
                `   üè∑Ô∏è Status: ${acc.status}\n` +
                `   üìß Owner: ${acc.owner_email}`
              ).join('\n\n') || 'No matching sub-accounts found.') +
              `\n\n**Full Response:**\n${JSON.stringify(result, null, 2)}`
      }]
    };
  } catch (error) {
    return handleCakemailError(error);
  }
}

// Get sub-accounts by status
export async function handleGetSubAccountsByStatus(args: any, api: CakemailAPI) {
  try {
    const { status, page, per_page } = args;

    if (!status) {
      return {
        content: [{
          type: 'text',
          text: '‚ùå **Missing Required Field**\n\nRequired: status (pending, active, suspended, inactive)'
        }]
      };
    }

    const result = await api.subAccounts.getSubAccountsByStatus(status, {
      page: page || 1,
      per_page: per_page || 50
    });

    const total = result.pagination?.count || 0;
    const accounts = result.data?.map((account: SubAccount) => ({
      id: account.id,
      name: account.name || 'N/A',
      status: account.status || 'N/A',
      owner_email: account.account_owner?.email || 'N/A',
      created_on: account.created_on || 'N/A'
    }));

    return {
      content: [{
        type: 'text',
        text: `üìä **Sub-Accounts by Status**\n\n` +
              `**Status Filter:** ${status}\n` +
              `**Found:** ${total} sub-accounts\n\n` +
              `**Results:**\n` +
              (accounts?.map((acc: any, i: number) => 
                `${i + 1}. **${acc.name}** (${acc.id})\n` +
                `   üè∑Ô∏è Status: ${acc.status}\n` +
                `   üìß Owner: ${acc.owner_email}\n` +
                `   üìÖ Created: ${acc.created_on}`
              ).join('\n\n') || `No sub-accounts found with status '${status}'.`) +
              `\n\n**Full Response:**\n${JSON.stringify(result, null, 2)}`
      }]
    };
  } catch (error) {
    return handleCakemailError(error);
  }
}

// Verify sub-account email (email verification workflows)
export async function handleVerifySubAccountEmail(args: any, api: CakemailAPI) {
  try {
    const { account_id, verification_code, email } = args;

    if (!account_id) {
      return {
        content: [{
          type: 'text',
          text: '‚ùå **Missing Required Field**\n\nRequired: account_id'
        }]
      };
    }

    // If verification_code is provided, use confirm endpoint
    if (verification_code) {
      const confirmData = { confirmation_code: verification_code };
      const result = await api.subAccounts.confirmSubAccount(account_id, confirmData);
      
      return {
        content: [{
          type: 'text',
          text: `‚úÖ **Sub-Account Email Verified Successfully**\n\n` +
                `üè¢ **Account Details:**\n` +
                `‚Ä¢ ID: ${account_id}\n` +
                `‚Ä¢ Verified: ${result.data?.confirmed ? 'Yes' : 'No'}\n` +
                `‚Ä¢ Verification Code: ${verification_code}\n\n` +
                `**Note:** The sub-account email has been verified and the account is now confirmed.\n\n` +
                `**Full Response:**\n${JSON.stringify(result, null, 2)}`
        }]
      };
    }
    
    // If email is provided, trigger resend verification
    if (email) {
      const result = await api.subAccounts.resendVerificationEmail({ email });
      
      return {
        content: [{
          type: 'text',
          text: `üìß **Email Verification Workflow Initiated**\n\n` +
                `**Email Details:**\n` +
                `‚Ä¢ Account ID: ${account_id}\n` +
                `‚Ä¢ Email: ${email}\n` +
                `‚Ä¢ Verification Resent: ${result.verification_resent ? 'Yes' : 'No'}\n\n` +
                `**Next Steps:**\n` +
                `1. Check the inbox (and spam folder) for verification email\n` +
                `2. Use the verification code with this tool to confirm\n\n` +
                `**Full Response:**\n${JSON.stringify(result, null, 2)}`
        }]
      };
    }
    
    // If neither verification_code nor email provided
    return {
      content: [{
        type: 'text',
        text: '‚ùå **Missing Required Field**\n\nRequired: Either verification_code (to verify) or email (to resend verification)'
      }]
    };
    
  } catch (error) {
    return handleCakemailError(error);
  }
}

// Debug sub-account access
export async function handleDebugSubAccountAccess(args: any, api: CakemailAPI) {
  try {
    const { account_id } = args;

    const result = await api.subAccounts.debugSubAccountAccess(account_id);

    let statusEmoji = '‚úÖ';
    if (result.access_check === 'failed') {
      statusEmoji = '‚ùå';
    }

    return {
      content: [{
        type: 'text',
        text: `${statusEmoji} **Sub-Account Access Debug**\n\n` +
              `**Access Check:** ${result.access_check}\n` +
              `**Timestamp:** ${result.timestamp}\n` +
              `**OpenAPI Compliance:** ${result.openapi_compliance}\n\n` +
              (account_id ? 
                `**Specific Account Test (${account_id}):**\n` +
                `‚Ä¢ Account Found: ${result.account_found ? 'Yes' : 'No'}\n` +
                `‚Ä¢ Validation: ${result.validation}\n` +
                (result.account_data ? `‚Ä¢ Account Name: ${result.account_data.name}\n` : '') +
                (result.account_data ? `‚Ä¢ Account Status: ${result.account_data.status}\n` : '') :
                `**General Access Test:**\n` +
                `‚Ä¢ Can List Accounts: ${result.can_list_accounts ? 'Yes' : 'No'}\n` +
                `‚Ä¢ Total Account Count: ${result.account_count}\n` +
                `‚Ä¢ Filter Validation: ${result.filter_validation}\n` +
                (result.first_few_accounts ? 
                  `‚Ä¢ Sample Accounts: ${result.first_few_accounts.map((acc: any) => acc.name).join(', ')}\n` : '')
              ) +
              (result.error ? `\n**Error:** ${result.error}` : '') +
              `\n\n**Full Debug Response:**\n${JSON.stringify(result, null, 2)}`
      }]
    };
  } catch (error) {
    return handleCakemailError(error);
  }
}
